// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kardiachain/remote/kv.proto

package remote

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/kardiachain/go-kardia/proto/kardiachain/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Op int32

const (
	Op_FIRST           Op = 0
	Op_FIRST_DUP       Op = 1
	Op_SEEK            Op = 2
	Op_SEEK_BOTH       Op = 3
	Op_CURRENT         Op = 4
	Op_LAST            Op = 6
	Op_LAST_DUP        Op = 7
	Op_NEXT            Op = 8
	Op_NEXT_DUP        Op = 9
	Op_NEXT_NO_DUP     Op = 11
	Op_PREV            Op = 12
	Op_PREV_DUP        Op = 13
	Op_PREV_NO_DUP     Op = 14
	Op_SEEK_EXACT      Op = 15
	Op_SEEK_BOTH_EXACT Op = 16
	Op_OPEN            Op = 30
	Op_CLOSE           Op = 31
)

var Op_name = map[int32]string{
	0:  "FIRST",
	1:  "FIRST_DUP",
	2:  "SEEK",
	3:  "SEEK_BOTH",
	4:  "CURRENT",
	6:  "LAST",
	7:  "LAST_DUP",
	8:  "NEXT",
	9:  "NEXT_DUP",
	11: "NEXT_NO_DUP",
	12: "PREV",
	13: "PREV_DUP",
	14: "PREV_NO_DUP",
	15: "SEEK_EXACT",
	16: "SEEK_BOTH_EXACT",
	30: "OPEN",
	31: "CLOSE",
}

var Op_value = map[string]int32{
	"FIRST":           0,
	"FIRST_DUP":       1,
	"SEEK":            2,
	"SEEK_BOTH":       3,
	"CURRENT":         4,
	"LAST":            6,
	"LAST_DUP":        7,
	"NEXT":            8,
	"NEXT_DUP":        9,
	"NEXT_NO_DUP":     11,
	"PREV":            12,
	"PREV_DUP":        13,
	"PREV_NO_DUP":     14,
	"SEEK_EXACT":      15,
	"SEEK_BOTH_EXACT": 16,
	"OPEN":            30,
	"CLOSE":           31,
}

func (x Op) String() string {
	return proto.EnumName(Op_name, int32(x))
}

func (Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c0a59bdcd31aa683, []int{0}
}

type Action int32

const (
	Action_STORAGE     Action = 0
	Action_UPSERT      Action = 1
	Action_CODE        Action = 2
	Action_UPSERT_CODE Action = 3
	Action_REMOVE      Action = 4
)

var Action_name = map[int32]string{
	0: "STORAGE",
	1: "UPSERT",
	2: "CODE",
	3: "UPSERT_CODE",
	4: "REMOVE",
}

var Action_value = map[string]int32{
	"STORAGE":     0,
	"UPSERT":      1,
	"CODE":        2,
	"UPSERT_CODE": 3,
	"REMOVE":      4,
}

func (x Action) String() string {
	return proto.EnumName(Action_name, int32(x))
}

func (Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c0a59bdcd31aa683, []int{1}
}

type Direction int32

const (
	Direction_FORWARD Direction = 0
	Direction_UNWIND  Direction = 1
)

var Direction_name = map[int32]string{
	0: "FORWARD",
	1: "UNWIND",
}

var Direction_value = map[string]int32{
	"FORWARD": 0,
	"UNWIND":  1,
}

func (x Direction) String() string {
	return proto.EnumName(Direction_name, int32(x))
}

func (Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c0a59bdcd31aa683, []int{2}
}

type Cursor struct {
	Op         Op     `protobuf:"varint,1,opt,name=op,proto3,enum=kardiachain.remote.Op" json:"op,omitempty"`
	BucketName string `protobuf:"bytes,2,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
	Cursor     uint32 `protobuf:"varint,3,opt,name=cursor,proto3" json:"cursor,omitempty"`
	K          []byte `protobuf:"bytes,4,opt,name=k,proto3" json:"k,omitempty"`
	V          []byte `protobuf:"bytes,5,opt,name=v,proto3" json:"v,omitempty"`
}

func (m *Cursor) Reset()         { *m = Cursor{} }
func (m *Cursor) String() string { return proto.CompactTextString(m) }
func (*Cursor) ProtoMessage()    {}
func (*Cursor) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0a59bdcd31aa683, []int{0}
}
func (m *Cursor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cursor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cursor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cursor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cursor.Merge(m, src)
}
func (m *Cursor) XXX_Size() int {
	return m.Size()
}
func (m *Cursor) XXX_DiscardUnknown() {
	xxx_messageInfo_Cursor.DiscardUnknown(m)
}

var xxx_messageInfo_Cursor proto.InternalMessageInfo

func (m *Cursor) GetOp() Op {
	if m != nil {
		return m.Op
	}
	return Op_FIRST
}

func (m *Cursor) GetBucketName() string {
	if m != nil {
		return m.BucketName
	}
	return ""
}

func (m *Cursor) GetCursor() uint32 {
	if m != nil {
		return m.Cursor
	}
	return 0
}

func (m *Cursor) GetK() []byte {
	if m != nil {
		return m.K
	}
	return nil
}

func (m *Cursor) GetV() []byte {
	if m != nil {
		return m.V
	}
	return nil
}

type Pair struct {
	K        []byte `protobuf:"bytes,1,opt,name=k,proto3" json:"k,omitempty"`
	V        []byte `protobuf:"bytes,2,opt,name=v,proto3" json:"v,omitempty"`
	CursorID uint32 `protobuf:"varint,3,opt,name=cursorID,proto3" json:"cursorID,omitempty"`
	TxID     uint64 `protobuf:"varint,4,opt,name=txID,proto3" json:"txID,omitempty"`
}

func (m *Pair) Reset()         { *m = Pair{} }
func (m *Pair) String() string { return proto.CompactTextString(m) }
func (*Pair) ProtoMessage()    {}
func (*Pair) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0a59bdcd31aa683, []int{1}
}
func (m *Pair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pair.Merge(m, src)
}
func (m *Pair) XXX_Size() int {
	return m.Size()
}
func (m *Pair) XXX_DiscardUnknown() {
	xxx_messageInfo_Pair.DiscardUnknown(m)
}

var xxx_messageInfo_Pair proto.InternalMessageInfo

func (m *Pair) GetK() []byte {
	if m != nil {
		return m.K
	}
	return nil
}

func (m *Pair) GetV() []byte {
	if m != nil {
		return m.V
	}
	return nil
}

func (m *Pair) GetCursorID() uint32 {
	if m != nil {
		return m.CursorID
	}
	return 0
}

func (m *Pair) GetTxID() uint64 {
	if m != nil {
		return m.TxID
	}
	return 0
}

type StorageChange struct {
	Location *types.H256 `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Data     []byte      `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *StorageChange) Reset()         { *m = StorageChange{} }
func (m *StorageChange) String() string { return proto.CompactTextString(m) }
func (*StorageChange) ProtoMessage()    {}
func (*StorageChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0a59bdcd31aa683, []int{2}
}
func (m *StorageChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageChange.Merge(m, src)
}
func (m *StorageChange) XXX_Size() int {
	return m.Size()
}
func (m *StorageChange) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageChange.DiscardUnknown(m)
}

var xxx_messageInfo_StorageChange proto.InternalMessageInfo

func (m *StorageChange) GetLocation() *types.H256 {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *StorageChange) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type AccountChange struct {
	Address        *types.H160      `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Incarnation    uint64           `protobuf:"varint,2,opt,name=incarnation,proto3" json:"incarnation,omitempty"`
	Action         Action           `protobuf:"varint,3,opt,name=action,proto3,enum=kardiachain.remote.Action" json:"action,omitempty"`
	Data           []byte           `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	Code           []byte           `protobuf:"bytes,5,opt,name=code,proto3" json:"code,omitempty"`
	StorageChanges []*StorageChange `protobuf:"bytes,6,rep,name=storageChanges,proto3" json:"storageChanges,omitempty"`
}

func (m *AccountChange) Reset()         { *m = AccountChange{} }
func (m *AccountChange) String() string { return proto.CompactTextString(m) }
func (*AccountChange) ProtoMessage()    {}
func (*AccountChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0a59bdcd31aa683, []int{3}
}
func (m *AccountChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountChange.Merge(m, src)
}
func (m *AccountChange) XXX_Size() int {
	return m.Size()
}
func (m *AccountChange) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountChange.DiscardUnknown(m)
}

var xxx_messageInfo_AccountChange proto.InternalMessageInfo

func (m *AccountChange) GetAddress() *types.H160 {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *AccountChange) GetIncarnation() uint64 {
	if m != nil {
		return m.Incarnation
	}
	return 0
}

func (m *AccountChange) GetAction() Action {
	if m != nil {
		return m.Action
	}
	return Action_STORAGE
}

func (m *AccountChange) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *AccountChange) GetCode() []byte {
	if m != nil {
		return m.Code
	}
	return nil
}

func (m *AccountChange) GetStorageChanges() []*StorageChange {
	if m != nil {
		return m.StorageChanges
	}
	return nil
}

// StateChangeBatch - list of StateDiff done in one DB transaction
type StateChangeBatch struct {
	DatabaseViewID      uint64         `protobuf:"varint,1,opt,name=databaseViewID,proto3" json:"databaseViewID,omitempty"`
	ChangeBatch         []*StateChange `protobuf:"bytes,2,rep,name=changeBatch,proto3" json:"changeBatch,omitempty"`
	PendingBlockBaseFee uint64         `protobuf:"varint,3,opt,name=pendingBlockBaseFee,proto3" json:"pendingBlockBaseFee,omitempty"`
	BlockGasLimit       uint64         `protobuf:"varint,4,opt,name=blockGasLimit,proto3" json:"blockGasLimit,omitempty"`
}

func (m *StateChangeBatch) Reset()         { *m = StateChangeBatch{} }
func (m *StateChangeBatch) String() string { return proto.CompactTextString(m) }
func (*StateChangeBatch) ProtoMessage()    {}
func (*StateChangeBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0a59bdcd31aa683, []int{4}
}
func (m *StateChangeBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateChangeBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateChangeBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateChangeBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateChangeBatch.Merge(m, src)
}
func (m *StateChangeBatch) XXX_Size() int {
	return m.Size()
}
func (m *StateChangeBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_StateChangeBatch.DiscardUnknown(m)
}

var xxx_messageInfo_StateChangeBatch proto.InternalMessageInfo

func (m *StateChangeBatch) GetDatabaseViewID() uint64 {
	if m != nil {
		return m.DatabaseViewID
	}
	return 0
}

func (m *StateChangeBatch) GetChangeBatch() []*StateChange {
	if m != nil {
		return m.ChangeBatch
	}
	return nil
}

func (m *StateChangeBatch) GetPendingBlockBaseFee() uint64 {
	if m != nil {
		return m.PendingBlockBaseFee
	}
	return 0
}

func (m *StateChangeBatch) GetBlockGasLimit() uint64 {
	if m != nil {
		return m.BlockGasLimit
	}
	return 0
}

// StateChange - changes done by 1 block or by 1 unwind
type StateChange struct {
	Direction   Direction        `protobuf:"varint,1,opt,name=direction,proto3,enum=kardiachain.remote.Direction" json:"direction,omitempty"`
	BlockHeight uint64           `protobuf:"varint,2,opt,name=blockHeight,proto3" json:"blockHeight,omitempty"`
	BlockHash   *types.H256      `protobuf:"bytes,3,opt,name=blockHash,proto3" json:"blockHash,omitempty"`
	Changes     []*AccountChange `protobuf:"bytes,4,rep,name=changes,proto3" json:"changes,omitempty"`
	Txs         [][]byte         `protobuf:"bytes,5,rep,name=txs,proto3" json:"txs,omitempty"`
}

func (m *StateChange) Reset()         { *m = StateChange{} }
func (m *StateChange) String() string { return proto.CompactTextString(m) }
func (*StateChange) ProtoMessage()    {}
func (*StateChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0a59bdcd31aa683, []int{5}
}
func (m *StateChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateChange.Merge(m, src)
}
func (m *StateChange) XXX_Size() int {
	return m.Size()
}
func (m *StateChange) XXX_DiscardUnknown() {
	xxx_messageInfo_StateChange.DiscardUnknown(m)
}

var xxx_messageInfo_StateChange proto.InternalMessageInfo

func (m *StateChange) GetDirection() Direction {
	if m != nil {
		return m.Direction
	}
	return Direction_FORWARD
}

func (m *StateChange) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *StateChange) GetBlockHash() *types.H256 {
	if m != nil {
		return m.BlockHash
	}
	return nil
}

func (m *StateChange) GetChanges() []*AccountChange {
	if m != nil {
		return m.Changes
	}
	return nil
}

func (m *StateChange) GetTxs() [][]byte {
	if m != nil {
		return m.Txs
	}
	return nil
}

type StateChangeRequest struct {
	WithStorage      bool `protobuf:"varint,1,opt,name=withStorage,proto3" json:"withStorage,omitempty"`
	WithTransactions bool `protobuf:"varint,2,opt,name=withTransactions,proto3" json:"withTransactions,omitempty"`
}

func (m *StateChangeRequest) Reset()         { *m = StateChangeRequest{} }
func (m *StateChangeRequest) String() string { return proto.CompactTextString(m) }
func (*StateChangeRequest) ProtoMessage()    {}
func (*StateChangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0a59bdcd31aa683, []int{6}
}
func (m *StateChangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateChangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateChangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateChangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateChangeRequest.Merge(m, src)
}
func (m *StateChangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *StateChangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StateChangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StateChangeRequest proto.InternalMessageInfo

func (m *StateChangeRequest) GetWithStorage() bool {
	if m != nil {
		return m.WithStorage
	}
	return false
}

func (m *StateChangeRequest) GetWithTransactions() bool {
	if m != nil {
		return m.WithTransactions
	}
	return false
}

func init() {
	proto.RegisterEnum("kardiachain.remote.Op", Op_name, Op_value)
	proto.RegisterEnum("kardiachain.remote.Action", Action_name, Action_value)
	proto.RegisterEnum("kardiachain.remote.Direction", Direction_name, Direction_value)
	proto.RegisterType((*Cursor)(nil), "kardiachain.remote.Cursor")
	proto.RegisterType((*Pair)(nil), "kardiachain.remote.Pair")
	proto.RegisterType((*StorageChange)(nil), "kardiachain.remote.StorageChange")
	proto.RegisterType((*AccountChange)(nil), "kardiachain.remote.AccountChange")
	proto.RegisterType((*StateChangeBatch)(nil), "kardiachain.remote.StateChangeBatch")
	proto.RegisterType((*StateChange)(nil), "kardiachain.remote.StateChange")
	proto.RegisterType((*StateChangeRequest)(nil), "kardiachain.remote.StateChangeRequest")
}

func init() { proto.RegisterFile("kardiachain/remote/kv.proto", fileDescriptor_c0a59bdcd31aa683) }

var fileDescriptor_c0a59bdcd31aa683 = []byte{
	// 945 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x55, 0x4d, 0x6f, 0x22, 0x47,
	0x13, 0x76, 0x0f, 0x63, 0x3e, 0x8a, 0x0f, 0xb7, 0x7a, 0x25, 0xbf, 0x88, 0xd5, 0x62, 0x5e, 0x64,
	0x59, 0xc8, 0x52, 0xc0, 0xcb, 0x6a, 0x57, 0x8a, 0x56, 0x8a, 0xc4, 0xc7, 0x78, 0x8d, 0xd6, 0x61,
	0x50, 0x33, 0x66, 0xad, 0x1c, 0x62, 0x35, 0x43, 0x07, 0x46, 0x18, 0x86, 0xcc, 0x34, 0x5e, 0xfb,
	0x9e, 0x5b, 0x2e, 0xf9, 0x59, 0x39, 0xee, 0x25, 0x52, 0x8e, 0x91, 0x7d, 0xc9, 0x39, 0xbf, 0x20,
	0xea, 0x9e, 0x01, 0x0f, 0x6b, 0xb2, 0x7b, 0x41, 0x55, 0x4f, 0x3d, 0x5d, 0xf5, 0x74, 0x75, 0x0d,
	0x05, 0xcf, 0xa7, 0xcc, 0x1b, 0x39, 0xcc, 0x9e, 0x30, 0x67, 0x5e, 0xf3, 0xf8, 0xcc, 0x15, 0xbc,
	0x36, 0xbd, 0xa9, 0x2e, 0x3c, 0x57, 0xb8, 0x84, 0x44, 0x82, 0xd5, 0x20, 0x58, 0x78, 0x3e, 0x76,
	0xdd, 0xf1, 0x35, 0xaf, 0x29, 0xc6, 0x70, 0xf9, 0x53, 0x8d, 0xcf, 0x16, 0xe2, 0x2e, 0x38, 0x50,
	0x78, 0x11, 0xcd, 0x26, 0xee, 0x16, 0xdc, 0x0f, 0x7e, 0x83, 0x70, 0xf9, 0x17, 0x04, 0xf1, 0xd6,
	0xd2, 0xf3, 0x5d, 0x8f, 0x1c, 0x81, 0xe6, 0x2e, 0xf2, 0xa8, 0x84, 0x2a, 0xb9, 0xfa, 0x7e, 0xf5,
	0x69, 0x9d, 0xaa, 0xb9, 0xa0, 0x9a, 0xbb, 0x20, 0x45, 0x80, 0xe1, 0xd2, 0x9e, 0x72, 0xd1, 0x65,
	0x33, 0x9e, 0xd7, 0x4a, 0xa8, 0x92, 0xa2, 0x11, 0x84, 0xec, 0x43, 0xdc, 0x56, 0x19, 0xf3, 0xb1,
	0x12, 0xaa, 0x64, 0x69, 0xe8, 0x91, 0x0c, 0xa0, 0x69, 0x5e, 0x2f, 0xa1, 0x4a, 0x86, 0xa2, 0xa9,
	0xf4, 0x6e, 0xf2, 0xbb, 0x81, 0x77, 0x53, 0xa6, 0xa0, 0xf7, 0x98, 0x13, 0x72, 0xd0, 0x06, 0x47,
	0x0b, 0x39, 0xa4, 0x00, 0xc9, 0x20, 0x53, 0xa7, 0x1d, 0x66, 0x5e, 0xfb, 0x84, 0x80, 0x2e, 0x6e,
	0x3b, 0x6d, 0x95, 0x5e, 0xa7, 0xca, 0x2e, 0x5f, 0x42, 0xb6, 0x2f, 0x5c, 0x8f, 0x8d, 0x79, 0x6b,
	0xc2, 0xe6, 0x63, 0x4e, 0x5e, 0x41, 0xf2, 0xda, 0xb5, 0x99, 0x70, 0xdc, 0xb9, 0xaa, 0x91, 0xae,
	0xff, 0x6f, 0xe3, 0x9a, 0x41, 0x5f, 0xce, 0xea, 0xaf, 0xdf, 0xd0, 0x35, 0x51, 0x66, 0x1e, 0x31,
	0xc1, 0x42, 0x19, 0xca, 0x2e, 0xff, 0xaa, 0x41, 0xb6, 0x61, 0xdb, 0xee, 0x72, 0x2e, 0xc2, 0xd4,
	0x2f, 0x21, 0xc1, 0x46, 0x23, 0x8f, 0xfb, 0xfe, 0x97, 0x32, 0xbf, 0x7c, 0x73, 0x42, 0x57, 0x3c,
	0x52, 0x82, 0xb4, 0x33, 0xb7, 0x99, 0x37, 0x0f, 0x04, 0x69, 0x4a, 0x79, 0x14, 0x22, 0x75, 0x88,
	0x33, 0x5b, 0x05, 0x63, 0xea, 0x51, 0x0a, 0xdb, 0x1e, 0xa5, 0xa1, 0x18, 0x34, 0x64, 0xae, 0xe5,
	0xea, 0x8f, 0x72, 0x25, 0x66, 0xbb, 0x23, 0x1e, 0x76, 0x5b, 0xd9, 0xa4, 0x03, 0x39, 0x3f, 0xda,
	0x1c, 0x3f, 0x1f, 0x2f, 0xc5, 0x2a, 0xe9, 0xfa, 0xff, 0xb7, 0xd5, 0xd8, 0x68, 0x23, 0xfd, 0xec,
	0x60, 0xf9, 0x0f, 0x04, 0xb8, 0x2f, 0x98, 0x08, 0x81, 0x26, 0x13, 0xf6, 0x84, 0x1c, 0x41, 0x4e,
	0xd6, 0x1e, 0x32, 0x9f, 0x0f, 0x1c, 0xfe, 0xb1, 0xd3, 0x56, 0x7d, 0xd1, 0xe9, 0x67, 0x28, 0x69,
	0x40, 0xda, 0x7e, 0x3c, 0x96, 0xd7, 0x94, 0x88, 0x83, 0xed, 0x22, 0xd6, 0x25, 0x68, 0xf4, 0x0c,
	0x39, 0x81, 0x67, 0x0b, 0x3e, 0x1f, 0x39, 0xf3, 0x71, 0xf3, 0xda, 0xb5, 0xa7, 0x4d, 0xe6, 0xf3,
	0x53, 0xce, 0x55, 0xcf, 0x74, 0xba, 0x2d, 0x44, 0x0e, 0x21, 0x3b, 0x94, 0xfe, 0x3b, 0xe6, 0x9f,
	0x3b, 0x33, 0x47, 0x84, 0x63, 0xb3, 0x09, 0x96, 0xff, 0x41, 0x90, 0x8e, 0x14, 0x25, 0x6f, 0x21,
	0x35, 0x72, 0x3c, 0x6e, 0xaf, 0xe7, 0x27, 0x57, 0x7f, 0xb1, 0x4d, 0x68, 0x7b, 0x45, 0xa2, 0x8f,
	0x7c, 0xf9, 0xda, 0x2a, 0xfb, 0x19, 0x77, 0xc6, 0x13, 0xb1, 0x7a, 0xed, 0x08, 0x44, 0x5e, 0x43,
	0x2a, 0x70, 0x99, 0x3f, 0x51, 0xe2, 0xbf, 0x30, 0x9e, 0x8f, 0x4c, 0xf2, 0x16, 0x12, 0x76, 0xf8,
	0x82, 0xfa, 0x7f, 0xbf, 0xe0, 0xc6, 0xb4, 0xd2, 0xd5, 0x09, 0x82, 0x21, 0x26, 0x6e, 0xfd, 0xfc,
	0x6e, 0x29, 0x56, 0xc9, 0x50, 0x69, 0x96, 0x87, 0x40, 0xa2, 0x8d, 0xe6, 0x3f, 0x2f, 0xb9, 0x2f,
	0xa4, 0xfa, 0x8f, 0x8e, 0x98, 0x84, 0x73, 0xa0, 0x2e, 0x9f, 0xa4, 0x51, 0x88, 0x1c, 0x03, 0x96,
	0xae, 0xe5, 0xb1, 0xb9, 0x1f, 0x8c, 0xa2, 0xaf, 0x2e, 0x99, 0xa4, 0x4f, 0xf0, 0xe3, 0xbf, 0x11,
	0x68, 0xe6, 0x82, 0xa4, 0x60, 0xf7, 0xb4, 0x43, 0xfb, 0x16, 0xde, 0x21, 0x59, 0x48, 0x29, 0xf3,
	0xaa, 0x7d, 0xd1, 0xc3, 0x88, 0x24, 0x41, 0xef, 0x1b, 0xc6, 0x7b, 0xac, 0xc9, 0x80, 0xb4, 0xae,
	0x9a, 0xa6, 0x75, 0x86, 0x63, 0x24, 0x0d, 0x89, 0xd6, 0x05, 0xa5, 0x46, 0xd7, 0xc2, 0xba, 0x64,
	0x9d, 0x37, 0xfa, 0x16, 0x8e, 0x93, 0x0c, 0x24, 0xa5, 0xa5, 0x4e, 0x27, 0x24, 0xde, 0x35, 0x2e,
	0x2d, 0x9c, 0x94, 0xb8, 0xb4, 0x14, 0x9e, 0x22, 0x7b, 0x90, 0x56, 0x5e, 0xd7, 0x54, 0x40, 0x5a,
	0x12, 0x7b, 0xd4, 0x18, 0xe0, 0x8c, 0x24, 0x4a, 0x4b, 0xe1, 0x59, 0x49, 0x54, 0x5e, 0x48, 0xcc,
	0x91, 0x1c, 0x80, 0x52, 0x61, 0x5c, 0x36, 0x5a, 0x16, 0xde, 0x23, 0xcf, 0x60, 0x6f, 0xad, 0x2a,
	0x04, 0xb1, 0xcc, 0x66, 0xf6, 0x8c, 0x2e, 0x2e, 0xca, 0x8b, 0xb5, 0xce, 0xcd, 0xbe, 0x81, 0x0f,
	0x8e, 0xcf, 0x20, 0x1e, 0x7c, 0xa0, 0x52, 0x7a, 0xdf, 0x32, 0x69, 0xe3, 0x9d, 0x81, 0x77, 0x08,
	0x40, 0xfc, 0xa2, 0xd7, 0x37, 0xa8, 0x15, 0x5c, 0xb6, 0x65, 0xb6, 0x0d, 0xac, 0xc9, 0xba, 0x01,
	0x7a, 0xa5, 0x80, 0x98, 0xa4, 0x51, 0xe3, 0x7b, 0x73, 0x60, 0x60, 0xfd, 0xf8, 0x10, 0x52, 0xeb,
	0xc1, 0x92, 0xc9, 0x4e, 0x4d, 0xfa, 0xa1, 0x41, 0xdb, 0x61, 0xb2, 0xee, 0x87, 0x4e, 0xb7, 0x8d,
	0x51, 0x5d, 0xb6, 0xf6, 0xfd, 0x80, 0x34, 0x21, 0x31, 0xe0, 0x9e, 0x2f, 0xa9, 0xfb, 0xd5, 0x60,
	0x3b, 0x54, 0x57, 0xdb, 0xa1, 0x6a, 0xc8, 0xed, 0x50, 0x38, 0xd8, 0x32, 0x5b, 0xe1, 0x19, 0xca,
	0x17, 0xd7, 0x77, 0xe4, 0x3b, 0xd0, 0xac, 0x5b, 0xb2, 0xf5, 0x3f, 0x27, 0x58, 0x18, 0x85, 0xfc,
	0xb6, 0x98, 0xfc, 0x1b, 0xaf, 0xa0, 0x13, 0x44, 0x7e, 0x84, 0x4c, 0x64, 0x92, 0x7c, 0x72, 0xf4,
	0xb5, 0x8f, 0x3a, 0x98, 0xb5, 0xc2, 0xe1, 0x57, 0x78, 0xea, 0xa3, 0x3f, 0x41, 0xcd, 0xfe, 0xef,
	0xf7, 0x45, 0xf4, 0xe9, 0xbe, 0x88, 0xfe, 0xba, 0x2f, 0xa2, 0xdf, 0x1e, 0x8a, 0x3b, 0x9f, 0x1e,
	0x8a, 0x3b, 0x7f, 0x3e, 0x14, 0x77, 0x7e, 0xf8, 0x76, 0xec, 0x88, 0xc9, 0x72, 0x58, 0xb5, 0xdd,
	0x59, 0x2d, 0xba, 0xfd, 0xc6, 0xee, 0x37, 0x81, 0x1b, 0x6c, 0xca, 0xda, 0xd3, 0x3d, 0x3b, 0x8c,
	0xab, 0xc8, 0xab, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xb4, 0xa3, 0xee, 0xc8, 0x84, 0x07, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// KVClient is the client API for KV service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type KVClient interface {
	// Version returns the service version number
	Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.VersionReply, error)
	// Tx exposes read-only transactions for the key-value store
	//
	// When tx open, client must receive 1 message from server with txID
	// When cursor open, client must receive 1 message from server with cursorID
	// Then only client can initiate messages from server
	Tx(ctx context.Context, opts ...grpc.CallOption) (KV_TxClient, error)
	StateChanges(ctx context.Context, in *StateChangeRequest, opts ...grpc.CallOption) (KV_StateChangesClient, error)
}

type kVClient struct {
	cc *grpc.ClientConn
}

func NewKVClient(cc *grpc.ClientConn) KVClient {
	return &kVClient{cc}
}

func (c *kVClient) Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.VersionReply, error) {
	out := new(types.VersionReply)
	err := c.cc.Invoke(ctx, "/kardiachain.remote.KV/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVClient) Tx(ctx context.Context, opts ...grpc.CallOption) (KV_TxClient, error) {
	stream, err := c.cc.NewStream(ctx, &_KV_serviceDesc.Streams[0], "/kardiachain.remote.KV/Tx", opts...)
	if err != nil {
		return nil, err
	}
	x := &kVTxClient{stream}
	return x, nil
}

type KV_TxClient interface {
	Send(*Cursor) error
	Recv() (*Pair, error)
	grpc.ClientStream
}

type kVTxClient struct {
	grpc.ClientStream
}

func (x *kVTxClient) Send(m *Cursor) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kVTxClient) Recv() (*Pair, error) {
	m := new(Pair)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kVClient) StateChanges(ctx context.Context, in *StateChangeRequest, opts ...grpc.CallOption) (KV_StateChangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_KV_serviceDesc.Streams[1], "/kardiachain.remote.KV/StateChanges", opts...)
	if err != nil {
		return nil, err
	}
	x := &kVStateChangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KV_StateChangesClient interface {
	Recv() (*StateChangeBatch, error)
	grpc.ClientStream
}

type kVStateChangesClient struct {
	grpc.ClientStream
}

func (x *kVStateChangesClient) Recv() (*StateChangeBatch, error) {
	m := new(StateChangeBatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// KVServer is the server API for KV service.
type KVServer interface {
	// Version returns the service version number
	Version(context.Context, *emptypb.Empty) (*types.VersionReply, error)
	// Tx exposes read-only transactions for the key-value store
	//
	// When tx open, client must receive 1 message from server with txID
	// When cursor open, client must receive 1 message from server with cursorID
	// Then only client can initiate messages from server
	Tx(KV_TxServer) error
	StateChanges(*StateChangeRequest, KV_StateChangesServer) error
}

// UnimplementedKVServer can be embedded to have forward compatible implementations.
type UnimplementedKVServer struct {
}

func (*UnimplementedKVServer) Version(ctx context.Context, req *emptypb.Empty) (*types.VersionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (*UnimplementedKVServer) Tx(srv KV_TxServer) error {
	return status.Errorf(codes.Unimplemented, "method Tx not implemented")
}
func (*UnimplementedKVServer) StateChanges(req *StateChangeRequest, srv KV_StateChangesServer) error {
	return status.Errorf(codes.Unimplemented, "method StateChanges not implemented")
}

func RegisterKVServer(s *grpc.Server, srv KVServer) {
	s.RegisterService(&_KV_serviceDesc, srv)
}

func _KV_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kardiachain.remote.KV/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Version(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _KV_Tx_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KVServer).Tx(&kVTxServer{stream})
}

type KV_TxServer interface {
	Send(*Pair) error
	Recv() (*Cursor, error)
	grpc.ServerStream
}

type kVTxServer struct {
	grpc.ServerStream
}

func (x *kVTxServer) Send(m *Pair) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kVTxServer) Recv() (*Cursor, error) {
	m := new(Cursor)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KV_StateChanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StateChangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KVServer).StateChanges(m, &kVStateChangesServer{stream})
}

type KV_StateChangesServer interface {
	Send(*StateChangeBatch) error
	grpc.ServerStream
}

type kVStateChangesServer struct {
	grpc.ServerStream
}

func (x *kVStateChangesServer) Send(m *StateChangeBatch) error {
	return x.ServerStream.SendMsg(m)
}

var _KV_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kardiachain.remote.KV",
	HandlerType: (*KVServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _KV_Version_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Tx",
			Handler:       _KV_Tx_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StateChanges",
			Handler:       _KV_StateChanges_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "kardiachain/remote/kv.proto",
}

func (m *Cursor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cursor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cursor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.V) > 0 {
		i -= len(m.V)
		copy(dAtA[i:], m.V)
		i = encodeVarintKv(dAtA, i, uint64(len(m.V)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.K) > 0 {
		i -= len(m.K)
		copy(dAtA[i:], m.K)
		i = encodeVarintKv(dAtA, i, uint64(len(m.K)))
		i--
		dAtA[i] = 0x22
	}
	if m.Cursor != 0 {
		i = encodeVarintKv(dAtA, i, uint64(m.Cursor))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BucketName) > 0 {
		i -= len(m.BucketName)
		copy(dAtA[i:], m.BucketName)
		i = encodeVarintKv(dAtA, i, uint64(len(m.BucketName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintKv(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Pair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TxID != 0 {
		i = encodeVarintKv(dAtA, i, uint64(m.TxID))
		i--
		dAtA[i] = 0x20
	}
	if m.CursorID != 0 {
		i = encodeVarintKv(dAtA, i, uint64(m.CursorID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.V) > 0 {
		i -= len(m.V)
		copy(dAtA[i:], m.V)
		i = encodeVarintKv(dAtA, i, uint64(len(m.V)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.K) > 0 {
		i -= len(m.K)
		copy(dAtA[i:], m.K)
		i = encodeVarintKv(dAtA, i, uint64(len(m.K)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintKv(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StorageChanges) > 0 {
		for iNdEx := len(m.StorageChanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StorageChanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintKv(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintKv(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintKv(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if m.Action != 0 {
		i = encodeVarintKv(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x18
	}
	if m.Incarnation != 0 {
		i = encodeVarintKv(dAtA, i, uint64(m.Incarnation))
		i--
		dAtA[i] = 0x10
	}
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StateChangeBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateChangeBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateChangeBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockGasLimit != 0 {
		i = encodeVarintKv(dAtA, i, uint64(m.BlockGasLimit))
		i--
		dAtA[i] = 0x20
	}
	if m.PendingBlockBaseFee != 0 {
		i = encodeVarintKv(dAtA, i, uint64(m.PendingBlockBaseFee))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ChangeBatch) > 0 {
		for iNdEx := len(m.ChangeBatch) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChangeBatch[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintKv(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DatabaseViewID != 0 {
		i = encodeVarintKv(dAtA, i, uint64(m.DatabaseViewID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Txs) > 0 {
		for iNdEx := len(m.Txs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Txs[iNdEx])
			copy(dAtA[i:], m.Txs[iNdEx])
			i = encodeVarintKv(dAtA, i, uint64(len(m.Txs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintKv(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.BlockHash != nil {
		{
			size, err := m.BlockHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockHeight != 0 {
		i = encodeVarintKv(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.Direction != 0 {
		i = encodeVarintKv(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateChangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithTransactions {
		i--
		if m.WithTransactions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.WithStorage {
		i--
		if m.WithStorage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintKv(dAtA []byte, offset int, v uint64) int {
	offset -= sovKv(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Cursor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovKv(uint64(m.Op))
	}
	l = len(m.BucketName)
	if l > 0 {
		n += 1 + l + sovKv(uint64(l))
	}
	if m.Cursor != 0 {
		n += 1 + sovKv(uint64(m.Cursor))
	}
	l = len(m.K)
	if l > 0 {
		n += 1 + l + sovKv(uint64(l))
	}
	l = len(m.V)
	if l > 0 {
		n += 1 + l + sovKv(uint64(l))
	}
	return n
}

func (m *Pair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.K)
	if l > 0 {
		n += 1 + l + sovKv(uint64(l))
	}
	l = len(m.V)
	if l > 0 {
		n += 1 + l + sovKv(uint64(l))
	}
	if m.CursorID != 0 {
		n += 1 + sovKv(uint64(m.CursorID))
	}
	if m.TxID != 0 {
		n += 1 + sovKv(uint64(m.TxID))
	}
	return n
}

func (m *StorageChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovKv(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovKv(uint64(l))
	}
	return n
}

func (m *AccountChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovKv(uint64(l))
	}
	if m.Incarnation != 0 {
		n += 1 + sovKv(uint64(m.Incarnation))
	}
	if m.Action != 0 {
		n += 1 + sovKv(uint64(m.Action))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovKv(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovKv(uint64(l))
	}
	if len(m.StorageChanges) > 0 {
		for _, e := range m.StorageChanges {
			l = e.Size()
			n += 1 + l + sovKv(uint64(l))
		}
	}
	return n
}

func (m *StateChangeBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseViewID != 0 {
		n += 1 + sovKv(uint64(m.DatabaseViewID))
	}
	if len(m.ChangeBatch) > 0 {
		for _, e := range m.ChangeBatch {
			l = e.Size()
			n += 1 + l + sovKv(uint64(l))
		}
	}
	if m.PendingBlockBaseFee != 0 {
		n += 1 + sovKv(uint64(m.PendingBlockBaseFee))
	}
	if m.BlockGasLimit != 0 {
		n += 1 + sovKv(uint64(m.BlockGasLimit))
	}
	return n
}

func (m *StateChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Direction != 0 {
		n += 1 + sovKv(uint64(m.Direction))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovKv(uint64(m.BlockHeight))
	}
	if m.BlockHash != nil {
		l = m.BlockHash.Size()
		n += 1 + l + sovKv(uint64(l))
	}
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovKv(uint64(l))
		}
	}
	if len(m.Txs) > 0 {
		for _, b := range m.Txs {
			l = len(b)
			n += 1 + l + sovKv(uint64(l))
		}
	}
	return n
}

func (m *StateChangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithStorage {
		n += 2
	}
	if m.WithTransactions {
		n += 2
	}
	return n
}

func sovKv(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozKv(x uint64) (n int) {
	return sovKv(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Cursor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cursor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cursor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cursor", wireType)
			}
			m.Cursor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cursor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K = append(m.K[:0], dAtA[iNdEx:postIndex]...)
			if m.K == nil {
				m.K = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V = append(m.V[:0], dAtA[iNdEx:postIndex]...)
			if m.V == nil {
				m.V = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K = append(m.K[:0], dAtA[iNdEx:postIndex]...)
			if m.K == nil {
				m.K = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V = append(m.V[:0], dAtA[iNdEx:postIndex]...)
			if m.V == nil {
				m.V = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CursorID", wireType)
			}
			m.CursorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CursorID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			m.TxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &types.H256{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &types.H160{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incarnation", wireType)
			}
			m.Incarnation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Incarnation |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= Action(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = append(m.Code[:0], dAtA[iNdEx:postIndex]...)
			if m.Code == nil {
				m.Code = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageChanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageChanges = append(m.StorageChanges, &StorageChange{})
			if err := m.StorageChanges[len(m.StorageChanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateChangeBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateChangeBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateChangeBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseViewID", wireType)
			}
			m.DatabaseViewID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseViewID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeBatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeBatch = append(m.ChangeBatch, &StateChange{})
			if err := m.ChangeBatch[len(m.ChangeBatch)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingBlockBaseFee", wireType)
			}
			m.PendingBlockBaseFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingBlockBaseFee |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockGasLimit", wireType)
			}
			m.BlockGasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockGasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockHash == nil {
				m.BlockHash = &types.H256{}
			}
			if err := m.BlockHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, &AccountChange{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, make([]byte, postIndex-iNdEx))
			copy(m.Txs[len(m.Txs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithStorage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithStorage = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithTransactions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithTransactions = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKv(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKv
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthKv
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupKv
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthKv
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthKv        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKv          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupKv = fmt.Errorf("proto: unexpected end of group")
)
